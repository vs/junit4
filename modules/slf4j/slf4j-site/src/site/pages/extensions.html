<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/2000/REC-xhtml1-20000126/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<title>SLF4J extensions</title>

<link rel="stylesheet" type="text/css" media="screen" href="css/site.css" />
</head>
<body>
	<script>
prefix='';	
</script>

<script src="templates/header.js"></script>
<div id="left">
  <script src="templates/left.js"></script>
</div>
<div id="right">
  <script src="templates/right.js"></script>
</div>
<div id="content">

    <h1>SLF4J extensions</h1>

    <p>SLF4J extensions are packaged within <em>slf4j-ext.jar</em>
    which ships with SLF4J.</p>

		<h2>Profilers</h2>

		<h2>What is a profiler?</h2>
    
    <p>According to wikipedia, <a
    href="http://en.wikipedia.org/wiki/Profiler_%28computer_science%29">profiling</a>
    is the investigation of a program's behavior using information
    gathered as the program runs, i.e. it is a form of dynamic program
    analysis, as opposed to static code analysis. The usual goal of
    performance analysis is to determine which parts of a program to
    optimize for speed or memory usage.
    </p>

    <p>SLF4J profilers, a.k.a. poor man's profilers, will help the
    developer gather performance data. Essentially, a profiler
    consists of one or more stopwatches. Stopwatches are driven
    (started/stopped) by statements in the <em>source code</em>. An
    example, should make the point clearer.
    </p>

    <h2>Basic example</h2>


    <em>Example: Using the profiler </em>

    <p class="source">

import ch.qos.logback.classic.stopwatch.Profiler;

public class BasicUsageExample {

  public static void main(String[] args) {
    <b>Profiler profiler = new Profiler("BASIC");</b>
    <b>profiler.start("A");</b>
    doA();
       
    <b>profiler.start("B");</b>
    for (int i = 0; i &lt; 5; i++) {
      doSubtaskTwo(i);
    }
    <b>profiler.start("doOther");</b>
    doOther();
    System.out.println(<b>profiler.stop().toString()</b>);
  }
  ... cut </p>

  <p>Running the above example will output the following output.</p>

    <p class="source">+ Profiler [BASIC]
|-- elapsed time                [A]  0.288 milliseconds.
|-- elapsed time                [B] 24.717 milliseconds.
|-- elapsed time            [Other] 22.085 milliseconds.
|-- Total elapsed time      [BASIC] 50.691 milliseconds.</p>

  
   <p>Instantiating a profiler starts a global stopwatch. Each call to
   the start() method starts a new and named stopwatch. In addition to
   sarting a named stopwatch, the start() method also causes the
   previous stopwatch to stop. Thus, the call to
   <code>profiler.start("A")</code> starts a stopwatch named "A". The
   subsequent call to <code>profiler.start("B")</code> starts
   stopwatch "B" and simultanously stops the stopwatch named
   "A". Invoking the <code>stop()</code> on a profiler method stops
   the last stopwatch as well as the global stopwatch which was
   started when the profiler was instantiated.
   </p>


   <h2>Profiler nesting</h2>
   
   <p>Profilers can also be nested. By nesting profilers, it is
   possible to measure a task which itself has subtasks that need to
   be timed and measured.
   </p>

   <p>Starting a nested profiler will stop any previously started
   stopwatch or nested profiler associated with the parent profiler.
   </p>
   
   <p>Often times, the subtask is implemented by a different class as
   the class hosting the parent profiler. Using the
   <code>ProfilerRegistry</code> is a convinient way of passing a
   nested profiler to an object outside the current object.
   </p>

   <em>Example: <a
   href="xref-test/org/slf4j/profiler/ProfilerDemo.html">ProfilerDemo</a>

</div>
</body>
</html>


